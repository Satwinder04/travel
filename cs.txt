sort list Given the head of a linked list, return the list after sorting it in ascending order.  
public class Solution {
    private ListNode findMid(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode slow = head, fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                curr.next = l1;
                l1 = l1.next;
            } else {
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }
        curr.next = (l1 != null) ? l1 : l2;
        return dummy.next;
    }

    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null)
            return head;
        ListNode mid = findMid(head);
        ListNode newHead = mid.next;
        mid.next = null;
        ListNode leftHalf = sortList(head);
        ListNode rightHalf = sortList(newHead);
        return merge(leftHalf, rightHalf);
    }
}


----------------------------------------------------------------------
Write a Java program to reverse a linked list. You are provided with a ListNode class representing each node of the linked list. 
Implement the reverseList method in the ReverseLinkedList class to reverse the given linked list and print the reversed list using the print method.


merge two linked list

package dsapractice;

import java.util.*;

class ListNode {
    int val;
    ListNode next;

    public ListNode() {
    }

    public ListNode(int val) {
        this.val = val;
    }

    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }

}

public class ReverseLinkedList {

    public static ListNode reverseList(ListNode head) {
        if (head == null || head.next == null)
            return head;

        ListNode prev = null, curr = head;
        while (curr != null) {
            ListNode nextNode = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextNode;
        }
        return prev;
    }

    public static void print(ListNode result) {
        while (result != null) {
            System.out.print(result.val + " ");
            result = result.next;
        }
        System.out.println(); // Adding a new line after printing the list
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        ListNode head = null;
        ListNode tail = null;

        for (int i = 0; i < n; i++) {
            int val = sc.nextInt();
            ListNode newNode = new ListNode(val);
            if (head == null) {
                head = newNode;
                tail = newNode;
            } else {
                tail.next = newNode;
                tail = newNode;
            }
        }

        head = reverseList(head); // Update the head with the new head of the reversed list
        print(head);
    }
}

-------------------------------------------------------------------------------------
Write a Java program to sort a singly linked list in ascending order. You are provided with a ListNode class representing each node of the linked list. Implement the sortList method in the dhf class to sort the given linked list using the Merge Sort algorithm and print the sorted list using the print method.

Input:

The first line contains an integer n, the number of elements in the linked list.
The next line contains n integers, representing the elements of the linked list.
Output:

Print the sorted linked list.


package dsapractice;

import java.util.*;

public class dhf {
    static class ListNode {
        int val;
        ListNode next;

        public ListNode() {
        }

        public ListNode(int val) {
            this.val = val;
        }

        public ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

    public static ListNode sortList(ListNode head) {
        return middleSort(head);
    }

    public static ListNode middleSort(ListNode head) {
        if (head == null || head.next == null) return head;

        ListNode slow = head, fast = head, prev = null;
        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        prev.next = null;
        ListNode head1 = middleSort(head);
        ListNode head2 = middleSort(slow);
        return merge(head1, head2);
    }

    public static ListNode merge(ListNode head1, ListNode head2) {
        ListNode ansHead = new ListNode(0);
        ListNode ansTail = ansHead;
        while (head1 != null && head2 != null) {
            if (head1.val <= head2.val) {
                ansTail.next = head1;
                head1 = head1.next;
            } else {
                ansTail.next = head2;
                head2 = head2.next;
            }
            ansTail = ansTail.next;
        }
        if (head1 != null) {
            ansTail.next = head1;
        }
        if (head2 != null) {
            ansTail.next = head2;
        }
        return ansHead.next;
    }

    public static void print(ListNode head) {
        while (head != null) {
            System.out.print(head.val + " ");
            head = head.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the length of list: ");
        int n = sc.nextInt();
        LinkedList<Integer> ls = new LinkedList<>();
        System.out.println("Enter the elements of list: ");
        for (int i = 0; i < n; i++) {
            ls.add(sc.nextInt());
        }

        ListNode dummy = new ListNode(-1);
        ListNode curr = dummy;
        for (int i = 0; i < ls.size(); i++) {
            int num = ls.get(i);
            curr.next = new ListNode(num);
            curr = curr.next;
        }
        ListNode head = dummy.next;

        ListNode sorted = sortList(head);
        print(sorted);
    }
}


---------------------------------------------------------------------------------------
K group 

package leetcode;
import java.util.*;


class Node {
    int val;
    Node next;
    Node() {}
    Node(int val) { this.val = val; }
    Node(int val, Node next) { this.val = val; this.next = next; }
}

public class kgroup {
    public int len(Node head) {
        int sz = 0;
        while (head != null) {
            sz++;
            head = head.next;
        }
        return sz;
    }

    public Node reverseKGroup(Node head, int k) {
        int n = len(head);
        int groups = n / k;
        Node prevHead = null, currHead = head, ansNode = null;
        for (int i = 0; i < groups; i++) {
            Node prev = null, curr = currHead, nextNode = null;
            for (int j = 0; j < k; j++) {
                nextNode = curr.next;
                curr.next = prev;
                prev = curr;
                curr = nextNode;
            }
            if (prevHead == null) {
                ansNode = prev;
            } else {
                prevHead.next = prev;
            }
            prevHead = currHead;
            currHead = curr;
        }
        prevHead.next = currHead;
        return ansNode;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Input list size
        System.out.println("Enter the number of elements in the linked list:");
        int size = scanner.nextInt();

        // Input list elements
        System.out.println("Enter the elements of the linked list:");
        Node head = null;
        Node tail = null;
        for (int i = 0; i < size; i++) {
            int val = scanner.nextInt();
            Node newNode = new Node(val);
            if (head == null) {
                head = newNode;
                tail = newNode;
            } else {
                tail.next = newNode;
                tail = newNode;
            }
        }
        print(head);
        
        // Input k value
//        System.out.println("Enter the value of k:");
//        int k = scanner.nextInt();
//
//        kgroup solution = new kgroup();
//        Node reversedList = solution.reverseKGroup(head, k);

        // Output the reversed list
//        System.out.println("Reversed list:");
//        while (reversedList != null) {
//            System.out.print(reversedList.val + " ");
//            reversedList = reversedList.next;
//        }
//
//        scanner.close();
    }
    
    public static void print(Node head) {
    	while(head!=null) {
    		System.out.print(head.val+" ");
    		head=head.next;
    	}
    	System.out.println();
    }
}


------------------------------------------------------------------
Remove Nth from end 


package leetcode;

//class ListNode {
//    int val;
//    ListNode next;
//    ListNode() {}
//    ListNode(int val) { this.val = val; }
//    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
//}

public class RemoveNthFromEnd {
    public static void main(String[] args) {
        // Create a sample linked list: 1 -> 2 -> 3 -> 4 -> 5
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);

        // Print the original linked list
        System.out.println("Original Linked List:");
        printLinkedList(head);

        // Call the removeNthFromEnd method
        int n = 2; // Remove the 2nd node from the end
        head = removeNthFromEnd(head, n);

        // Print the modified linked list
        System.out.println("\nModified Linked List after removing the " + n + "th node from the end:");
        printLinkedList(head);
    }

    public static ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode fast = dummy, slow = dummy;

        // Move fast pointer n steps ahead
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
        }

        // Move both pointers simultaneously until fast reaches the end
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }

        // Remove the nth node from the end
        slow.next = slow.next.next;

        return dummy.next;
    }

    public static void printLinkedList(ListNode head) {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val + " ");
            current = current.next;
        }
    }
}
-----------------------------------------------------------------
delete duplicate

package leetcode;

class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
        val = x;
        next = null;
    }
}

public class dltduplicate {
	public ListNode deleteDuplicates(ListNode head) {
	    ListNode current = head;

	    while (current != null && current.next != null) {
	        if (current.val == current.next.val) {
	            // Skip all the nodes with the duplicate value
	            current.next = current.next.next;
	        } else {
	            // Move current one step forward
	            current = current.next;
	        }
	    }

	    return head;
	}

    public static void main(String[] args) {
        // Test your code here
        // Create sample linked list
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(3);
        head.next.next.next.next = new ListNode(4);
        head.next.next.next.next.next = new ListNode(4);
        head.next.next.next.next.next.next = new ListNode(5);

        // Create an instance of Solution class
        dltduplicate solution = new dltduplicate();

        // Call deleteDuplicates method and print the result
        ListNode result = solution.deleteDuplicates(head);
        while (result != null) {
            System.out.print(result.val + " ");
            result = result.next;
        }
    }
}


---------------------------------------------------------------------
Kth node end 

package leetcode;

//Define the ListNode class within the Solution.java file
//class ListNode {
// int val;
// ListNode next;
// 
// ListNode() {}
// 
// ListNode(int val) {
//     this.val = val;
// }
// 
// ListNode(int val, ListNode next) {
//     this.val = val;
//     this.next = next;
// }
//}

//Define the Solution class with a main method
public class kthnodeend {
 public static void main(String[] args) {
     // Create a sample linked list: 1 -> 2 -> 3 -> 4 -> 5 -> 6
     ListNode head = new ListNode(1);
     head.next = new ListNode(2);
     head.next.next = new ListNode(3);
     head.next.next.next = new ListNode(4);
     head.next.next.next.next = new ListNode(5);
     head.next.next.next.next.next = new ListNode(6);
     
     // Define the value of n (the position of the node to remove)
     int n = 5;
     
     // Call the removeNthFromEnd method and print the result
     ListNode result = removeNthFromEnd(head, n);
     printList(result);
 }
 
 // Define the removeNthFromEnd method
 public static ListNode removeNthFromEnd(ListNode head, int n) {
     ListNode fast = head, slow = head;
     for (int i = 0; i < n; i++) {
         fast = fast.next;
     }
     
     if (fast == null) {
         return head.next;
     }
         
     while (fast.next != null) {
         slow = slow.next;
         fast = fast.next;
     }
     
     slow.next = slow.next.next;
     return head;
 }
 
 // Helper method to print the linked list
 public static void printList(ListNode head) {
     while (head != null) {
         System.out.print(head.val + " ");
         head = head.next;
     }
     System.out.println();
 }
}
---------------------------------------------------------
abc reverse list

package leetcode;

import java.util.*;
import java.io.*;

public class abc {
 public static void main(String args[]) {
 Scanner sc = new Scanner(System.in);
 int n = sc.nextInt();
 ListNode head = new ListNode(-1);
 ListNode cur = head;
 for(int i=0;i<n;i++){
 int val = sc.nextInt();
 cur.next = new ListNode(val);
 cur = cur.next;
 }
 ListNode ans = reverseList(head.next);
 while(ans!=null){
 System.out.print(ans.val+" ");
 ans = ans.next;
 }
 }
 public static class ListNode {
 int val;
 ListNode next;
 ListNode() {}
 ListNode(int val) { this.val = val; }
 ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 }
 
 public static ListNode reverseList(ListNode head) {
 if(head==null || head.next==null) return head;
 
 //5 -> 4 -> 3 -> 2 -> 1
 ListNode ans = reverseList(head.next);
 head.next.next=head;
//loop avoid
 head.next=null;
 
 return ans;
 }
}

----------------------------------------------------
Two sum 

package leetcode;

import java.util.HashMap;

class Solution {
	public int[] twoSum(int[] nums, int target) {
		HashMap<Integer, Integer> map = new HashMap<>();
		// fill
		for (int i = 0; i < nums.length; i++) {
			map.put(nums[i], i);
		}
		// searching
		for (int i = 0; i < nums.length; i++) {
			int n = nums[i];
			int rem = target - n;
			if (map.containsKey(rem)) {
				int index = map.get(rem);
				if (index == i)
					continue;
				return new int[] { index, i };
			}
		}
		return new int[] {};
	}
}

public class Twosum {
	public static void main(String[] args) {
		Solution solution = new Solution();
		int[] nums = { 2, 7, 11, 15 };
		int target = 9;
		int[] result = solution.twoSum(nums, target);
		System.out.println("{" + result[0] + "," + result[1] + "}");
	}
}
--------------------------------------------------
PlusOne66


package leetcode;

import java.util.*;

public class PlusOne66 {
    public int[] plusOne(int[] digits) {
        int n = digits.length;
        for (int i = n - 1; i >= 0; i--) {
            if (digits[i] != 9) {
                digits[i]++;
                break;
            } else {
                digits[i] = 0;
            }
        }
        if (digits[0] == 0) {
            int[] res = new int[n + 1];
            res[0] = 1;
            return res;
        }
        return digits;
    }

    public static void main(String[] args) {
        PlusOne66 solution = new PlusOne66();
        int[] digits = {1,2,3};
        int[] result = solution.plusOne(digits);
        System.out.println(Arrays.toString(result));
    }
}
----------------------------------------------------\\
Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

 

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
Example 3:

Input: nums = [], target = 0
Output: [-1,-1]
 

Constraints:

0 <= nums.length <= 105
-109 <= nums[i] <= 109
nums is a non-decreasing array.
-109 <= target <= 109




package leetcode;

public class leetcode34firstandlast {
    public int[] searchRange(int[] nums, int target) {
    	
        int res[] =new int[2];
        int first = binarySearch(nums , target, true);
        int last = binarySearch(nums, target, false);
        res[0]=first;
        res[1]=last;
        return res;

    }
    static int binarySearch(int arr[], int target, boolean isFirst ){
        int ans = -1;
        int start = 0;
        int end = arr.length - 1;
        while(start<=end){
            int mid = start + (end - start)/2;
            if(arr[mid]==target){
                ans = mid;
                if(isFirst){
                    end = mid -1;
                }else{
                    start = mid +1;
                }
            }else if (arr[mid]<target){
                start = mid+1;
            }
            else{
              end = mid -1;
            }
        }
        return ans;

    }
}
-----------------------------------------------
MergeTwoSortedLists


package leetcode;
//Definition for singly-linked list
class ListNode1 {
 int val;
 ListNode1 next;
 ListNode1() {}
 ListNode1(int val) { this.val = val; }
 ListNode1(int val, ListNode1 next) { this.val = val; this.next = next; }
}

public class MergeTwoSortedLists {
 public static void main(String[] args) {
     // Example input: list1 = [1,2,4], list2 = [1,3,4]
     ListNode1 list1 = new ListNode1(1, new ListNode1(2, new ListNode1(4)));
     ListNode1 list2 = new ListNode1(1, new ListNode1(3, new ListNode1(4)));

     MergeTwoSortedLists solution = new MergeTwoSortedLists();
     ListNode1 mergedList = solution.mergeTwoLists(list1, list2);

     // Print the merged list
     while (mergedList != null) {
         System.out.print(mergedList.val + " ");
         mergedList = mergedList.next;
     }
 }

 public ListNode1 mergeTwoLists(ListNode1 list1, ListNode1 list2) {
     ListNode1 dummy= new ListNode1(-1);
     ListNode1 curr= dummy;
     while(list1 != null && list2 !=null){
         if(list1.val<list2.val){
             curr.next=list1;
             list1=list1.next;
         }else{
             curr.next=list2;
             list2=list2.next;
         }
         curr=curr.next;
     }
     if(list1 != null){
         curr.next=list1;
     }else{
         curr.next=list2;
     }
     
     return dummy.next;
 }

}
-----------------------------------------------------
random pointer


import java.util.*;

class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the number of nodes: ");
        int n = scanner.nextInt();
        
        Node[] nodes = new Node[n];
        
        // Nodes banane ke liye loop
        for (int i = 0; i < n; i++) {
            System.out.print("Node ke liye value daalo " + (i+1) + ": ");
            int val = scanner.nextInt();
            nodes[i] = new Node(val);
        }
        
        // Next pointers set karne ke liye loop
        for (int i = 0; i < n - 1; i++) {
            nodes[i].next = nodes[i + 1];
        }
        
        // Random pointers set karne ke liye loop
        for (int i = 0; i < n; i++) {
            System.out.print("Node " + (i+1) + " ka random pointer kis node ko point karega (agar null hai toh -1 daalo): ");
            int randomIndex = scanner.nextInt();
            if (randomIndex != -1) {
                nodes[i].random = nodes[randomIndex];
            }
        }
        
        // Linked list ko print karne ke liye loop
        Node head = nodes[0];
        while (head != null) {
            System.out.print(head.val + " ");
            head = head.next;
        }
        System.out.println();
        
        // Random pointers ko print karne ke liye loop
        head = nodes[0];
        while (head != null) {
            if (head.random != null) {
                System.out.print(head.random.val + " ");
            } else {
                System.out.print("-1 ");
            }
            head = head.next;
        }
    }
}
--------------------------------------------------
Reverse Nodes in k-Group leetcode 25
class Solution(object):
    def reverseKGroup(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        def reverseLinkedList(head, k):
            prev = None
            curr = head
            while k > 0 and curr:
                next_node = curr.next
                curr.next = prev
                prev = curr
                curr = next_node
                k -= 1
            return prev
        
        dummy = ListNode(0)
        dummy.next = head
        prev_group_end = dummy
        while True:
            # Check if there are at least k nodes left
            start = prev_group_end.next
            end = prev_group_end
            for _ in range(k):
                if end.next:
                    end = end.next
                else:
                    return dummy.next  # No more nodes to reverse
            
            # Save the next group's start
            next_group_start = end.next
            
            # Reverse the current group
            end.next = None  # Disconnect the end of the current group
            prev_group_end.next = reverseLinkedList(start, k)
            
            # Reconnect the reversed group
            start.next = next_group_start
            
            # Update prev_group_end for the next iteration
            prev_group_end = start
        
        return dummy.next

-------------------------------
19. Remove Nth Node From End of List


/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int l = 0;
        ListNode x = head;
        while(x!=null) {
            x = x.next;
            l++;
        }
        int y=l-n;
        if(y==0) {
            return head.next;
        }
        x=head;
        for(int i=1;i<y;i++) {
            x=x.next;
        }
        x.next = x.next.next;
        return head;
    }
}
----------------------------------
Merge k Sorted Lists leetcode 23
public class Solution {
    public ListNode mergeKLists(List<ListNode> lists) {
        if (lists==null||lists.size()==0) return null;
        
        PriorityQueue<ListNode> queue= new PriorityQueue<ListNode>(lists.size(),new Comparator<ListNode>(){
            @Override
            public int compare(ListNode o1,ListNode o2){
                if (o1.val<o2.val)
                    return -1;
                else if (o1.val==o2.val)
                    return 0;
                else 
                    return 1;
            }
        });
        
        ListNode dummy = new ListNode(0);
        ListNode tail=dummy;
        
        for (ListNode node:lists)
            if (node!=null)
                queue.add(node);
            
        while (!queue.isEmpty()){
            tail.next=queue.poll();
            tail=tail.next;
            
            if (tail.next!=null)
                queue.add(tail.next);
        }
        return dummy.next;
    }
}

---------------------------
138  Copy List with Random Pointer


class Solution {
    public Node copyRandomList(Node head) {
        // Check if the original list is empty
        if (head == null)
            return null;
        
        // Initialize the copied list with the value from the original head
        Node originalCopy = new Node(head.val);
        Node copiedHead = originalCopy;
        Node current = head;
        
        // Create a mapping between nodes in the original list and their copies
        HashMap<Node, Node> referenceMap = new HashMap<>();
        referenceMap.put(current, copiedHead);
        current = current.next;

        // Copy the rest of the nodes in the list
        while (current != null) {
            copiedHead.next = new Node(current.val);
            referenceMap.put(current, copiedHead.next);
            current = current.next;
            copiedHead = copiedHead.next;
        }

        // Reset pointers for traversing both original and copied lists
        current = head;
        copiedHead = originalCopy;

        // Populate the 'random' pointers in the copied list using the mapping
        while (current != null) {
            copiedHead.random = referenceMap.get(current.random);
            current = current.next;
            copiedHead = copiedHead.next;
        }

        // Return the head of the copied list
        return originalCopy;
    }
}
------------------------------------------
Reverse Linked List 206

class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;  
        ListNode current = head;
    
        
        while(current != null) { 
            ListNode next = current.next; 
            current.next = prev;
            prev = current;
            current = next;
        }
       return prev; 
    }
}

--------------------
Power of Two 231

class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n == 1)return true;
        if(n<1) return false;
        while(n>1){
            if(n%2 != 0){
                return false;
            }
            n = n/2;
        }
        return true;
    }
}
------------------------------
141. Linked List Cycle

public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;

        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;

            if (fast == slow) {
                return true;
            }
        }

        return false;        
    }
}

__________________________________________________________________________
ST2

Q1. Two Sum

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

 

Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]
 

Constraints:

2 <= nums.length <= 10^4
-10^9 <= nums[i] <= 10^9
-10^9 <= target <= 10^9
Only one valid answer exists.

Solution:
import java.util.*;
import java.io.*;

public class Solution {
  public static void main(String args[]) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int a[] = new int[n];
    for(int i=0;i<n;i++){
      a[i] = sc.nextInt();
    }
    int target = sc.nextInt();
    int ans[] = twoSum(a,target);
    System.out.println(ans[0]+" "+ans[1]);
  }
  public static int[] twoSum(int[] nums, int target) {
    Map<Integer,Integer>  map = new HashMap<>();

    int n=nums.length;
    for(int i=0;i<n;i++){
        if(map.containsKey(target-nums[i])){
            int value_id = map.get(target-nums[i]);
            
            int ans[] = new int[2];
            ans[0]=value_id;
            ans[1]=i;
            return ans;
            
        }
        map.put(nums[i],i);
    }
    
    return new int[]{-1,-1};
}

}

Test Cases:

Input: 
13
5 67 -2 895 2582 682 55 -275 2 -872 25 0 -275
5
Output: 
0 11

Input: 
9
6 2 5 7 -52 -27 -72 -722 -87     
-20
Output: 
3 5

Input: 
9
7 3 295 92 592 59825 29824 982 595     
985
Output:
1 7

Input: 
11
7 23 -482 -825 -69 -82 58 2 592 92 -92     
25
Output: 
1 7

Input: 
13
82 9 92 191 492 4951 -51 21954 -5 2935 -24 -2 9     
80
Output: 
0 11


2. Sliding Window Maximum

You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

Return the max sliding window.

Example 1:
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

Example 2:
Input: nums = [1], k = 1
Output: [1]
 

Constraints:

1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
1 <= k <= nums.length

Solution:
import java.util.*;
import java.io.*;

public class Solution {
  public static void main(String args[]) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int a[] = new int[n];
    for(int i=0;i<n;i++){
      a[i] = sc.nextInt();
    }
    int k = sc.nextInt();
    int ans[] = maxSlidingWindow(a,k);
    for(int i=0;i<ans.length;i++){
      System.out.print(ans[i]+" ");
    }
  }
  public static int[] maxSlidingWindow(int[] nums, int k) {
    int n=nums.length;
    if(n<k) return new int[0];
    
    int ans[] = new int[n-k+1];
    Deque<Integer> dq = new ArrayDeque<>();
    
    for(int i=0;i<k;i++){
        while(!dq.isEmpty() && nums[ dq.peekLast() ]<= nums[i]){
            dq.removeLast();
        }
        
        dq.addLast(i);
    }
    
    ans[0] = nums[ dq.peekFirst() ];
    
    for(int i=k;i<n;i++){
        
        //remove out of window element
        if(dq.peekFirst()<=i-k){
            dq.removeFirst();
        }
        
        //include current element
        //in decreasing order
        while(!dq.isEmpty() && nums[ dq.peekLast() ]< nums[i]){
            dq.removeLast();
        }
        
        //add
        dq.addLast(i);
        
        // System.out.println(dq);
        //  i=k-1
//             put=0
        //k=3
        //i=2
        ans[i-k+1] = nums[ dq.peekFirst() ];
        
        
    }
    
    
    return ans;
}


}


TestCase:
Input:  
13
5 67 -2 895 2582 682 55 -275 2 -872 25 0 -275    
5
Output:  
2582 2582 2582 2582 2582 682 55 25 25 


Input:  
9
6 2 5 7 -52 -27 -72 -722 -87    
2
Output:  
6 5 7 7 -27 -27 -72 -87 


Input:  
9
7 3 295 92 592 5925 2984 982 595    
5
Output:  
592 5925 5925 5925 5925


Input:  
11
7 23 -482 -825 -69 -82 58 2 592 92 -92    
4
Output:  
23 23 -69 58 58 592 592 592 


Input:  
13
82 9 92 191 492 4951 -51 2154 -5 2935 -24 -2 9    
7
Output:  
4951 4951 4951 4951 4951 4951 2935


3. Reverse Linked List

Given the head of a singly linked list, reverse the list, and return the reversed list.

Example 1:
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]

Example 2:
Input: head = [1,2]
Output: [2,1]

Example 3:
Input: head = []
Output: []
 

Constraints:

The number of nodes in the list is the range [0, 5000].
-5000 <= Node.val <= 5000

Solution:
import java.util.*;
import java.io.*;

public class Solution {
  public static void main(String args[]) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    ListNode head = new ListNode(-1);
    ListNode cur = head;
    for(int i=0;i<n;i++){
      int val = sc.nextInt();
      cur.next = new ListNode(val);
      cur = cur.next;
    }

    ListNode ans = reverseList(head.next);
    while(ans!=null){
      System.out.print(ans.val+" ");
      ans = ans.next;
    }
  }
  public static class ListNode {
       int val;
       ListNode next;
       ListNode() {}
       ListNode(int val) { this.val = val; }
       ListNode(int val, ListNode next) { this.val = val; this.next = next; }
  }
   
  public static ListNode reverseList(ListNode head) {
        if(head==null || head.next==null)  return head;
        
        
        //5 -> 4 -> 3 -> 2 -> 1
        ListNode ans = reverseList(head.next);
        head.next.next=head;
        //loop avoid
        head.next=null;
        
        return ans;
    }



}

TestCase:
Input:  
6
3 2 1 5 6 4
Output:  
4 6 5 1 2 3 

Input:  
9
3 2 3 1 2 4 5 5 6 
Output:  
6 5 5 4 2 1 3 2 3 

Input:  
10
9 3 5 4 0 5 5 2 2 0 
Output:  
0 2 2 5 5 0 4 5 3 9 

Input:  
7
6 2 -2 26 -29 2 5 
Output:  
5 2 -29 26 -2 2 6

Input:  
7
9 2985 82 92 0 -82 -27
Output:  
-27 -82 0 92 82 2985 9


4. Copy List with Random Pointer

A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.

Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.

For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.

Return the head of the copied linked list.

The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:

val: an integer representing Node.val
random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.
Your code will only be given the head of the original linked list.

Input Format:
1.	Take user input
2.	Take array value
3.	Take node index in which random pointer is pointing to. Index -1 means random pointer pointing to null. 


Example 1:
Input: 
5
7 13 11 10 1
-1 0 4 2 0
Output: 
7 13 11 10 1 
-1 7 1 11 7

Example 2:
Input: 
2
1 2
1 1
Output: 
1 2 
2 2

Example 3:
Input: 
3
3 3 3
-1 0 -1
Output: 
3 3 3 
-1 3 -1


Constraints:
0 <= n <= 1000
0 <= Node.val <= 10^4
Node.random is null or is pointing to some node in the linked list.

Solution:
import java.util.*;
import java.io.*;

public class Solution {
  public static void main(String args[]) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    ListNode head = new ListNode(-1);
    ListNode cur = head;
    ListNode save[] = new ListNode[n];

    for(int i=0;i<n;i++){
      int val = sc.nextInt();
      cur.next = new ListNode(val);
      cur = cur.next;
      save[i] = cur;
    }

    cur = head.next;
    for(int i=0;i<n;i++){
      int val = sc.nextInt();

      if(val!=-1)  cur.random = save[val];

      cur = cur.next;

    }

    

    // ListNode ans = reverseList(head.next);

    ListNode ans = head.next;
    cur = ans;
    while(cur!=null){
      System.out.print(cur.val+" ");
      cur = cur.next;
    }

    System.out.println();
    
    cur = ans;
    while(cur!=null){
      if(cur.random==null)  System.out.print(-1+" ");
      else  System.out.print(cur.random.val+" ");
      cur = cur.next;
    }
  }
  public static class ListNode {
       int val;
       ListNode next;
       ListNode random=null;
       ListNode() {}
       ListNode(int val) { this.val = val; }
       ListNode(int val, ListNode next) { this.val = val; this.next = next; }
  }
   
  public static ListNode reverseList(ListNode head) {
        if(head==null || head.next==null)  return head;
        
        
        //5 -> 4 -> 3 -> 2 -> 1
        ListNode ans = reverseList(head.next);
        head.next.next=head;
        //loop avoid
        head.next=null;
        
        return ans;
    }



}

TestCases:
Input: 
5
7 13 11 10 1
-1 0 4 2 0
Output: 
7 13 11 10 1 
-1 7 1 11 7

Input: 
4
7 13 11 10
2 0 1 -1 
Output: 
7 13 11 10 
11 7 13 -1

Input: 
6
35 85 46 8 22 4
2 0 5 3 -1 0 
Output: 
35 85 46 8 22 4 
46 35 4 8 -1 35 

Input: 
7
9 2 2 202 92 0 82
3 6 5 0 2 -1 4 
Output: 
9 2 2 202 92 0 82 
202 82 0 9 2 -1 92 

Input: 
5
3 85 11 202 0
-1 0 1 0 -1 
Output: 
3 85 11 202 0 
-1 3 85 3 -1

______________________________________________________________________________

ST1

Question 1:
Generate Parenthesis

Given an integer 'n'. Print all the possible pairs of 'n' balanced parentheses.
The output strings should be printed in the sorted order considering '(' has higher value than ')'.

Input Format

Single line containing an integral value 'n'.

Constraints

1<=n<=11

Output Format

Print the balanced parentheses strings with every possible solution on new line.


Sample Input


2


Sample Output



()() 
(()) 

Solution: 

import java.util.*;
public class Main {
    public static void main(String args[]) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        generate(n,0,0,"");
    }
    public static void generate (int n,int l,int r, String ans){
        if(r==n){
            System.out.println(ans);
            return;
        }
        if(r<l){
            generate(n,l,r+1,ans+")");
        }
        if(l<n){
            generate(n,l+1,r,ans+"(");
        }
    }
}
------------------------------------------

Question 2:

permutation of string without duplicates

Given a String s , you have to all the possible permutations of s and while generating if there comes any duplicate permutation you have to avoid it .

Input Format

String s in first line of input

Output Format

all possible permutations of string s (without duplicate permutations) in separate lines

Sample Input

abc

Sample Output

abc
acb
bac
bca
cab
cba


Solution: 

import java.util.Scanner;

public class String_permutation_without_duplicates {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc=new Scanner(System.in);
		String s=sc.next();
		permutations(s,"");
	}
	public static void permutations(String s, String ans) {
		if (s.length() == 0) {
			System.out.println(ans);
			return;
		}
		boolean[] arr=new boolean[26];
		
		for (int i = 0; i < s.length(); i++) {
			
			char ch = s.charAt(i);
			if(arr[ch-'a']==false) {
				arr[ch-'a']=true;
				String s1 = s.substring(0, i);
				String s2 = s.substring(i + 1);
				permutations(s1 + s2, ans + ch);				
			}
		}

	}

}


---------------------------

Question 3:

Lexicographical count

Take as input N, a number. Write a recursive function which prints counting from 0 to N in lexicographical order. In lexicographical (dictionary) order 10, 100 and 109 will be printed before 11.

Input Format

Enter a number N.

Output Format

Display all the numbers upto N in a lexicographical order


Sample Input



10



Sample Output



0 1 10 2 3 4 5 6 7 8 9 


Solution: 

import java.util.*;
public class Main {
    public static void main(String args[]) {
        // Your Code Here
        Scanner sc=new Scanner (System.in);
        int n=sc.nextInt();
        Counting(0,n);

    }
    public static void Counting(int curr, int end) {
        if (curr > end) {
            return;
        }

        System.out.print(curr+" ");
        int i = 0;
        if (curr == 0) {
            i = 1;
        }

        for (; i <= 9; i++) {
            Counting(curr * 10 + i, end);
        }

    }
}
---------------------
Question 4:

Code to string
Take as input str, a string. Assume that value of a=1, b=2, c=3, d=4, …. z=26. Write a recursive function (return type Arraylist) to print all possible codes for the string. E.g. for “1123” possible codes are aabc, kbc, alc, aaw, kw.


Input:



A positive integer n (1 <= n <= 3000)



Output:



An ArrayList containing all possible codes



Example:



Input: n = 1125

Output: [aabe, aay, ale, kbe, ky]


SOLUTION:


import java.util.ArrayList;
import java.util.Scanner;

public class Recursion_Codes_of_string {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc=new Scanner(System.in);
		String s=sc.next();
		ArrayList<String> li=new ArrayList<>();
		outcomes(s,"",li);
		System.out.println(li);
	}

	private static void outcomes(String s, String ans, ArrayList<String> li) {
		// TODO Auto-generated method stub
		if(s.length()==0) {
//			System.out.println(ans);
			li.add(ans);
			return;
		}
		outcomes(s.substring(1), ans+(char)(s.charAt(0)-'1'+'a'),li);
		if(s.length()>=2&&Integer.parseInt(s.substring(0,2))<=26){
			outcomes(s.substring(2), ans+(char)(Integer.parseInt(s.substring(0,2))+'a'-1),li);			
		}
	}

}

____________________________________g

Sliding Window
import java.util.*;

public class Main {
    public static int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0 || k <= 0) {
            return new int[0];
        }
        
        int n = nums.length;
        int[] result = new int[n - k + 1];
        Deque<Integer> deque = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            // Remove indices outside the current window
            while (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            
            // Remove indices of elements smaller than the current element
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.pollLast();
            }
            
            // Add current index to the deque
            deque.offer(i);
            
            // Add maximum element of the current window to the result
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peek()];
            }
        }

        return result;
    }

    public static void main(String[] args) {
        int[] nums = {1, 3, -1, -3, 5, 3, 6, 7};
        int k = 3;

        int[] result = maxSlidingWindow(nums, k);

        // Print the result
        System.out.print("[");
        for (int i = 0; i < result.length; i++) {
            System.out.print(result[i]);
            if (i < result.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
}



Two Sum
import java.util.HashMap;

public class Main {
    public static int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }
            map.put(nums[i], i);
        }
        
        throw new IllegalArgumentException("No two sum solution");
    }
    
    public static void main(String[] args) {
        int[] nums = {2, 7, 11, 15};
        int target = 13;
        
        int[] result = twoSum(nums, target);
        
        System.out.println("Output: [" + result[0] + ", " + result[1] + "]");
    }
}

Kth largest element in an array
import java.util.Random;

public class Main {
    public static int findKthLargest(int[] nums, int k) {
        // Convert kth largest to kth smallest problem
        k = nums.length - k;
        int left = 0;
        int right = nums.length - 1;
        
        while (left < right) {
            int pivotIndex = partition(nums, left, right);
            if (pivotIndex < k) {
                left = pivotIndex + 1;
            } else if (pivotIndex > k) {
                right = pivotIndex - 1;
            } else {
                break;
            }
        }
        
        return nums[k];
    }
    
    private static int partition(int[] nums, int left, int right) {
        int randomIndex = new Random().nextInt(right - left + 1) + left;
        swap(nums, randomIndex, right);
        
        int pivot = nums[right];
        int i = left - 1;
        
        for (int j = left; j < right; j++) {
            if (nums[j] <= pivot) {
                i++;
                swap(nums, i, j);
            }
        }
        
        swap(nums, i + 1, right);
        return i + 1;
    }
    
    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
    public static void main(String[] args) {
        int[] nums = {3, 2, 1, 5, 6, 4};
        int k = 1;
        
        int result = findKthLargest(nums, k);
        
        System.out.println("Output: " + result);
    }
}

Reverse of a linked list

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
    }
}

public class Main {
    public static ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;
        
        while (current != null) {
            ListNode nextNode = current.next;
            current.next = prev;
            prev = current;
            current = nextNode;
        }
        
        return prev;
    }

    public static void main(String[] args) {
        // Create a sample linked list: 1 -> 2 -> 3 -> 4 -> 5
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);

        // Reverse the linked list
        ListNode reversedList = reverseList(head);

        // Print the reversed linked list
        while (reversedList != null) {
            System.out.print(reversedList.val + " ");
            reversedList = reversedList.next;
        }
    }
}

Copy list with a random pointer

import java.util.HashMap;
import java.util.Map;

class Node {
    int val;
    Node next, random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}

public class Main {
    public static Node copyRandomList(Node head) {
        if (head == null) return null;

        // Create a mapping from original nodes to their corresponding new nodes
        Map<Node, Node> map = new HashMap<>();

        // Create new nodes and populate the mapping
        Node current = head;
        while (current != null) {
            map.put(current, new Node(current.val));
            current = current.next;
        }

        // Assign next and random pointers for new nodes
        current = head;
        while (current != null) {
            map.get(current).next = map.get(current.next);
            map.get(current).random = map.get(current.random);
            current = current.next;
        }

        // Return the head of the new list
        return map.get(head);
    }

    public static void main(String[] args) {
        // Construct the original linked list
        Node head = new Node(7);
        head.next = new Node(13);
        head.next.next = new Node(11);
        head.next.next.next = new Node(10);
        head.next.next.next.next = new Node(1);

        // Set random pointers
        head.random = null;
        head.next.random = head;
        head.next.next.random = head.next.next.next.next;
        head.next.next.next.random = head.next.next;
        head.next.next.next.next.random = head;

        // Copy the linked list
        Node copiedHead = copyRandomList(head);

        // Print the copied list (val and random_index)
        Node current = copiedHead;
        while (current != null) {
            int randomIndex = current.random != null ? current.random.val : -1;
            System.out.println("[" + current.val + "," + randomIndex + "]");
            current = current.next;
        }
    }
}

Kth element from last linked list
import java.util.Scanner;

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Create the linked list
        ListNode head = createList(scanner);

        // Input k
        int k = scanner.nextInt();

        // Find kth element from end
        int result = findKthFromEnd(head, k);
        if (result == -1)
            System.out.println("Invalid input or k is greater than the length of the list");
        else
            System.out.println(result);

        scanner.close();
    }

    public static ListNode createList(Scanner scanner) {
        ListNode dummy = new ListNode(-1);
        ListNode curr = dummy;

        while (true) {
            int val = scanner.nextInt();
            if (val == -1) break;
            curr.next = new ListNode(val);
            curr = curr.next;
        }

        return dummy.next;
    }

    public static int findKthFromEnd(ListNode head, int k) {
        if (head == null || k <= 0) return -1; // Invalid input

        ListNode slow = head;
        ListNode fast = head;

        // Move fast pointer k steps ahead
        for (int i = 0; i < k; i++) {
            if (fast == null) return -1; // If k is greater than the length of the list
            fast = fast.next;
        }

        // Move slow and fast pointers simultaneously until fast reaches the end
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }

        // At this point, slow is at the kth element from the end
        return slow.val;
    }
}

Input 
1 2 3 4 5 -1
6




Triplet from linked list
import java.util.*;

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Input sizes of the three linked lists
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int k = scanner.nextInt();

        // Create the three linked lists
        ListNode headA = createList(scanner, n);
        ListNode headB = createList(scanner, m);
        ListNode headC = createList(scanner, k);

        // Input the target
        int target = scanner.nextInt();

        // Find the nodes from each list whose sum equals the target
        findTriplet(headA, headB, headC, target);

        scanner.close();
    }

    public static ListNode createList(Scanner scanner, int size) {
        ListNode dummy = new ListNode(-1);
        ListNode curr = dummy;

        for (int i = 0; i < size; i++) {
            int val = scanner.nextInt();
            curr.next = new ListNode(val);
            curr = curr.next;
        }

        return dummy.next;
    }

    public static void findTriplet(ListNode headA, ListNode headB, ListNode headC, int target) {
        HashSet<Integer> complementSet = new HashSet<>();

        ListNode currA = headA;
        while (currA != null) {
            ListNode currB = headB;
            while (currB != null) {
                ListNode currC = headC;
                while (currC != null) {
                    int sum = currA.val + currB.val + currC.val;
                    if (sum == target) {
                        System.out.println(currA.val + " " + currB.val + " " + currC.val);
                        return;
                    }
                    currC = currC.next;
                }
                currB = currB.next;
            }
            currA = currA.next;
        }

        System.out.println("No triplet found.");
    }
}
Input 
3 3 3
1 2 3 
4 5 6
7 8 9
10

Rotate linked list k times 

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static ListNode rotateRight(ListNode head, int k) {
        if (head == null || k == 0) return head;

        // Find the length of the linked list and the tail node
        int length = 1;
        ListNode tail = head;
        while (tail.next != null) {
            tail = tail.next;
            length++;
        }

        // Adjust k to be within the length of the list
        k %= length;
        if (k == 0) return head; // No rotation needed

        // Find the new tail and break the cycle
        ListNode newTail = head;
        for (int i = 0; i < length - k - 1; i++) {
            newTail = newTail.next;
        }
        ListNode newHead = newTail.next;
        newTail.next = null;

        // Connect the original tail to the original head to form a cycle
        tail.next = head;

        return newHead;
    }

    public static void printList(ListNode head) {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val + " ");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create the linked list: 1 -> 2 -> 3 -> 4 -> 5
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);

        int k = 2;

        // Rotate the list
        ListNode rotatedList = rotateRight(head, k);

        // Print the rotated list
        printList(rotatedList);
    }
}

Middle element of a linked list
class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static ListNode middleNode(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode slow = head;
        ListNode fast = head;

        // Move slow pointer one step at a time
        // Move fast pointer two steps at a time
        // When fast reaches the end, slow will be at the middle
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    public static void main(String[] args) {
        // Create the linked list: 1 -> 2 -> 3 -> 4 -> 5
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);

        // Get the middle node of the list
        ListNode middle = middleNode(head);

        // Print the values of nodes starting from the middle node
        while (middle != null) {
            System.out.print(middle.val + " ");
            middle = middle.next;
        }
    }
}

Panlindrome of a linked list 
class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }

        // Find the middle node of the linked list
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Reverse the second half of the linked list
        ListNode secondHalf = reverseList(slow.next);

        // Compare the first half with the reversed second half
        ListNode p1 = head;
        ListNode p2 = secondHalf;
        while (p2 != null) {
            if (p1.val != p2.val) {
                // Not a palindrome
                return false;
            }
            p1 = p1.next;
            p2 = p2.next;
        }

        // If reached here, it's a palindrome
        return true;
    }

    public static ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;

        while (current != null) {
            ListNode nextNode = current.next;
            current.next = prev;
            prev = current;
            current = nextNode;
        }

        return prev;
    }

    public static void main(String[] args) {
        // Create the linked list: 1 -> 2 -> 2 -> 1
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(2);
        head.next.next.next = new ListNode(1);

        // Check if the linked list is a palindrome
        boolean result = isPalindrome(head);
        System.out.println(result);
    }
}

Intersection of two linked list
class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Main {
    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }

        // Get the lengths of both lists
        int lenA = getListLength(headA);
        int lenB = getListLength(headB);

        // Move the longer list's head pointer forward by the difference in lengths
        while (lenA > lenB) {
            headA = headA.next;
            lenA--;
        }

        while (lenB > lenA) {
            headB = headB.next;
            lenB--;
        }

        // Traverse both lists until an intersection point is found
        while (headA != null && headB != null) {
            if (headA == headB) {
                return headA; // Intersection point found
            }
            headA = headA.next;
            headB = headB.next;
        }

        return null; // No intersection found
    }

    public static int getListLength(ListNode head) {
        int length = 0;
        ListNode current = head;
        while (current != null) {
            length++;
            current = current.next;
        }
        return length;
    }

    public static void main(String[] args) {
        // Create the first linked list: 4 -> 1 -> 8 -> 4 -> 5
        ListNode headA = new ListNode(4);
        headA.next = new ListNode(1);
        headA.next.next = new ListNode(8);
        headA.next.next.next = new ListNode(4);
        headA.next.next.next.next = new ListNode(5);

        // Create the second linked list: 5 -> 6 -> 1 -> 8 -> 4 -> 5
        ListNode headB = new ListNode(5);
        headB.next = new ListNode(6);
        headB.next.next = new ListNode(1);
        headB.next.next.next = headA.next.next; // Point to the intersection node in list A

        // Find the intersection node
        ListNode intersectionNode = getIntersectionNode(headA, headB);

        // Print the value of the intersection node
        if (intersectionNode != null) {
            System.out.println("Intersected at " + intersectionNode.val);
        } else {
            System.out.println("No intersection found.");
        }
    }
}

Lca of binary tree
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

public class Main {
    public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) {
            return root;
        }

        // Check left subtree for LCA
        TreeNode leftLCA = lowestCommonAncestor(root.left, p, q);

        // Check right subtree for LCA
        TreeNode rightLCA = lowestCommonAncestor(root.right, p, q);

        // If one node is found in the left subtree and the other in the right subtree,
        // then the current node is the LCA
        if (leftLCA != null && rightLCA != null) {
            return root;
        }

        // Otherwise, return the non-null node found in one of the subtrees
        return leftLCA != null ? leftLCA : rightLCA;
    }

    public static void main(String[] args) {
        // Construct the binary tree
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(5);
        root.right = new TreeNode(1);
        root.left.left = new TreeNode(6);
        root.left.right = new TreeNode(2);
        root.left.right.left = new TreeNode(7);
        root.left.right.right = new TreeNode(4);
        root.right.left = new TreeNode(0);
        root.right.right = new TreeNode(8);

        // Nodes to find LCA for
        TreeNode p = root.left;
        TreeNode q = root.right;

        // Find the lowest common ancestor
        TreeNode lca = lowestCommonAncestor(root, p, q);

        // Print the value of the lowest common ancestor
        System.out.println("LCA of " + p.val + " and " + q.val + " is " + lca.val);
    }
}

Balance binary tree
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

public class Main {
    public static boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true; // An empty tree is height-balanced
        }

        // Check if the left subtree is balanced
        int leftHeight = getHeight(root.left);
        if (leftHeight == -1) {
            return false; // Left subtree is not balanced
        }

        // Check if the right subtree is balanced
        int rightHeight = getHeight(root.right);
        if (rightHeight == -1) {
            return false; // Right subtree is not balanced
        }

        // Check if the current node is balanced
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return false; // Current node is not balanced
        }

        // Current node is balanced if both subtrees are balanced
        return true;
    }

    public static int getHeight(TreeNode node) {
        if (node == null) {
            return 0; // Height of an empty tree is 0
        }

        // Get the height of the left subtree
        int leftHeight = getHeight(node.left);
        if (leftHeight == -1) {
            return -1; // Left subtree is not balanced
        }

        // Get the height of the right subtree
        int rightHeight = getHeight(node.right);
        if (rightHeight == -1) {
            return -1; // Right subtree is not balanced
        }

        // Check if the current node is balanced
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1; // Current node is not balanced
        }

        // Height of the current node
        return Math.max(leftHeight, rightHeight) + 1;
    }

    public static void main(String[] args) {
        // Construct the binary tree
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(9);
        root.right = new TreeNode(20);
        root.right.left = new TreeNode(15);
        root.right.right = new TreeNode(7);

        // Check if the binary tree is height-balanced
        boolean balanced = isBalanced(root);

        // Print the result
        System.out.println(balanced);
    }
}

Symmetric tree
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

public class Main {
    public static boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true; // An empty tree is symmetric
        }
        return isMirror(root.left, root.right);
    }

    public static boolean isMirror(TreeNode leftSubtree, TreeNode rightSubtree) {
        // Base case: if both subtrees are null, they are mirror images
        if (leftSubtree == null && rightSubtree == null) {
            return true;
        }
        // If one subtree is null and the other is not, they are not mirror images
        if (leftSubtree == null || rightSubtree == null) {
            return false;
        }
        // If the values of the current nodes are not equal, they are not mirror images
        if (leftSubtree.val != rightSubtree.val) {
            return false;
        }
        // Check if the left subtree of the left node is symmetric to the right subtree of the right node
        // and if the right subtree of the left node is symmetric to the left subtree of the right node
        return isMirror(leftSubtree.left, rightSubtree.right) && isMirror(leftSubtree.right, rightSubtree.left);
    }

    public static void main(String[] args) {
        // Construct the binary tree
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(2);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(4);
        root.right.left = new TreeNode(4);
        root.right.right = new TreeNode(3);

        // Check if the binary tree is symmetric
        boolean symmetric = isSymmetric(root);

        // Print the result
        System.out.println(symmetric);
    }
}

Generate paranthesis
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        generateParenthesisHelper(n, 0, 0, "", result);
        return result;
    }

    public static void generateParenthesisHelper(int n, int openCount, int closeCount, String current, List<String> result) {
        // Base case: If the length of the current string equals 2*n, add it to the result list
        if (current.length() == 2 * n) {
            result.add(current);
            return;
        }

        // If the number of open parentheses is less than n, add an open parenthesis
        if (openCount < n) {
            generateParenthesisHelper(n, openCount + 1, closeCount, current + "(", result);
        }

        // If the number of close parentheses is less than the number of open parentheses, add a close parenthesis
        if (closeCount < openCount) {
            generateParenthesisHelper(n, openCount, closeCount + 1, current + ")", result);
        }
    }

    public static void main(String[] args) {
        // Input value of n
        int n = 3;

        // Generate all combinations of well-formed parentheses
        List<String> combinations = generateParenthesis(n);

        // Print the result
        System.out.println(combinations);
    }
}

